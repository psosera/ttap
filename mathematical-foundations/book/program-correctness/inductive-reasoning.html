<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Inductive Reasoning - Tools for Thinking About Programs: Mathematical Foundations</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././book.css">
        <link rel="stylesheet" href=".././mdbook-admonish.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Tools for Thinking About Programs: Mathematical Foundations</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="inductive-reasoning"><a class="header" href="#inductive-reasoning">Inductive Reasoning</a></h1>
<h2 id="review-of-recursive-design"><a class="header" href="#review-of-recursive-design">Review of Recursive Design</a></h2>
<p>The workhorse of functional programming is <em>recursion</em>.
Recursion allows us to perform repetitive behavior by defining an operation in terms of a smaller version of itself.
However, recursion is not just something you learn in Racket and summarily forget about for the rest of your career.
Recursion is pervasive everywhere in computer science, especially in algorithmic design.</p>
<p>Because of this, we must know how to reason about recursive programs.
Our model of computation is robust enough to trace the execution of recursive programs.
However, our formal reasoning tools fall short in letting us prove properties of these programs.
We introduce <em>induction</em> one of the foundational reasoning principles in mathematics and computer science, to account for this disparity.</p>
<h3 id="a-review-of-lists"><a class="header" href="#a-review-of-lists">A Review of Lists</a></h3>
<p>Lists are a common data structure found in most modern programming languages.
Python is no exception!</p>
<p>Like numbers, there are an infinite number of possible lists, <em>e.g.</em>,</p>
<ul>
<li><code>[]</code></li>
<li><code>[3, 5, 8]</code></li>
<li><code>["Hi", "goodbye", "!"]</code></li>
<li><code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>.</li>
</ul>
<p>However, our <em>recursive</em> definition of a list categorizes these infinite possibilities into a <em>finite</em> set of cases.</p>
<div id="admonition-definition-list" class="admonition admonish-info" role="note" aria-labelledby="admonition-definition-list-title">
<div class="admonition-title">
<div id="admonition-definition-list-title">
<p>Definition (List)</p>
</div>
<a class="admonition-anchor-link" href="#admonition-definition-list"></a>
</div>
<div>
<p>A <em>list</em> is either:</p>
<ul>
<li>Empty, or</li>
<li>Non-empty, consisting of a <em>head</em> element and the remainder of the list, its <em>tail</em>.</li>
</ul>
</div>
</div>
<p>This definition is similar to that of a boolean, where we define a boolean as one of two possible values: <code>True</code> or <code>False</code>.
However, the definition of a list is recursive because the non-empty case includes a component that is also a list.</p>
<h4 id="accessing-lists-recursively"><a class="header" href="#accessing-lists-recursively">Accessing Lists Recursively</a></h4>
<p>In Python, we typically operate over lists much like an array with indexing operations and mutation.
However, we can easily write functions that allow us to operate on lists according to our recursive definition, similarly to Scheme.</p>
<pre><code class="language-python">def is_empty(l):
    '''is_empty(l) returns true if list l is empty'''
    return len(l) == 0

def head(l):
    '''head(l) returns the element at the front of (non-empty) list l'''
    return l[0]

def tail(l):
    '''tail(l) returns (non-empty) list l, but without its head element'''
    return l[1:]
</code></pre>
<p>The implementation of the <code>tail</code> function, in particular, takes advantage of Python's <em>list slicing</em> expressions.
<code>l[n:m]</code> returns a list containing the elements of <code>l</code> starting at index <code>n</code>, ending at index <code>m</code> (exclusive).
When we elide <code>m</code> in a list slice, <code>m</code> becomes <code>len(l)</code>, <em>i.e.</em>, the last index of the list.</p>
<p>We can create lists explicitly with list literal notation, <em>e.g.</em>, <code>[1, 2, 3, 4, 5]</code>.
Additionally, we can write a "cons" function:</p>
<pre><code class="language-python">def cons(x, l):
    '''cons(x, l) returns list l but with element x at the front'''
    return [x, *l]
</code></pre>
<p>That allows us to add an element to the front of a list.
The implementation of <code>cons</code> uses Python's <em>sequence unpacking</em> expression where <code>*l</code> takes the elements of list <code>l</code> and, effectively, injects them into a context where a sequence is expected.
Here, the elements of <code>l</code> become the remaining elements of the list literal that <code>cons</code> returns.</p>
<div id="admonition-exercise" class="admonition admonish-question" role="note" aria-labelledby="admonition-exercise-title">
<div class="admonition-title">
<div id="admonition-exercise-title">
<p>Exercise</p>
</div>
<a class="admonition-anchor-link" href="#admonition-exercise"></a>
</div>
<div>
<p>Predict the results of each of the following expressions:</p>
<ol>
<li><code>head([1, 2, 3])</code></li>
<li><code>tail([1, 2, 3])</code></li>
<li><code>head(tail(tail([1, 2, 3])))</code></li>
<li><code>is_empty(tail(tail(tail([1, 2, 3]))))</code></li>
</ol>
</div>
</div>
<h4 id="recursive-design-with-lists"><a class="header" href="#recursive-design-with-lists">Recursive Design with Lists</a></h4>
<p>Because lists are defined via a finite set of cases, we define operations over lists using a combination of the <code>is_empty</code> function to determine which kind of list we have and <code>head</code> and <code>tail</code> to access parts of the list.
For some simple operations, this is enough to get by, <em>e.g.</em>, a function that retrieves the second element of a list:</p>
<pre><code class="language-python">def second(l):
    if is_empty(l):
        raise ValueError('empty list given')
    elif is_empty(tail(l)):
        raise ValueError('singleton list given')
    else:
        return head(tail(l))
</code></pre>
<p>We can translate this code to a high-level description:</p>
<ul>
<li>If the list is empty, throw an error (via Python's <code>raise</code> statement).</li>
<li>If the list contains one element, throw an error.</li>
<li>If the list has at least two elements, retrieve the second element.</li>
</ul>
<p>However, mere case analysis doesn't allow us to write more complex behavior.
Consider the prototypical example of a recursive function: computing the length of a list.
Let's first consider a high-level <em>recursive design</em> of the operation of this function, call it <code>length(l)</code>.
Because a list is either empty or non-empty, this leads to straightforward case analysis.
The empty case is straightforward:</p>
<ul>
<li>If the list is empty, its length is <code>0</code>.</li>
</ul>
<p>However, in the non-empty case, it isn't immediately clear how we should proceed.
We can draw the non-empty case of a list <code>l</code> with head element <code>v</code> and tail <code>tl</code> as follows:</p>
<pre><code>l = [v][ ?? tl ?? ]
</code></pre>
<p>Besides knowing that <code>tl</code> is a list, we don't know anything about it---it is an <em>arbitrary list</em>.
So how can we compute the length of <code>l</code> in this case?
We proceed by <em>decomposing</em> the length according to the parts of the lists we can access:</p>
<pre><code>length =  1 + length t
l      = [h][ ?? t ?? ]
</code></pre>
<p>We know that the head element <code>h</code> contributes <code>1</code> to the overall length of <code>l</code>.
How much does the tail of the list <code>t</code> contribute?
Since <code>t</code> is, itself, a list, <code>t</code> contributes whatever <code>length(t)</code> produces.
But this is a call to the same function that we are defining, albeit with a smaller list than the original input!</p>
<p>Critically, as long as the call to <code>length(t)</code> works, the overall design of <code>length</code> is correct.
This assumption that we make---that the recursive call "just works" as long as it is passed a "smaller" input---is called the <em>recursive assumption</em>, and it is the distinguishing feature of recursion compared to simple case analysis.</p>
<p>In summary, we define <code>length</code> recursively as follows:</p>
<blockquote>
<p>The length of a list <code>l</code> is:</p>
<ul>
<li><code>0</code> if <code>l</code> is empty.</li>
<li><code>1</code> plus the length of the tail of <code>l</code> if <code>l</code> is non-empty.</li>
</ul>
</blockquote>
<p>In the recursive case of the definition, our recursive assumption allows us to conclude that the "length of the tail of <code>l</code>" is well-defined.</p>
<p>Our high-level recursive design of <code>length</code> admits a direct translation into Racket using our list functions:</p>
<pre><code class="language-python">def length(l):
    if is_empty(l):
        return 0
    else:
        return 1 + length(tail(l))
</code></pre>
<p>Because the translation is immediate from the high-level recursive design, we can be confident our function is correct provided that the design is correct.</p>
<h4 id="pattern-matching-with-lists"><a class="header" href="#pattern-matching-with-lists">Pattern Matching with Lists</a></h4>
<p>Recall that one of our design goals is to write programs that are correct from inspection.
In particular, when we have a recursive design, we want our code to look like that design.
Let's see how our recursive definition of <code>length</code> fares in this respect.
Below, we have replicated the definition of <code>length</code> with the recursive design in-lined in comments:</p>
<pre><code class="language-python">def length(l):
    if is_empty(l):             # A list is either empty or non-empty.
        return 0                # + The empty list has zero length.
    else:                       # + A non-empty list has...
        hd = head(l)            #     - A head element hd and
        tl = tail(l)            #     - A tail element tl.
        return 1 + length(tl)   #   The length of a non-empty list is
                                #   plus the length of the tail.
</code></pre>
<p>In this version of the code, we explicitly bind the head and tail of <code>l</code> to be clear where these components of <code>l</code> are manipulated.</p>
<p>Overall, this isn't too bad!
Like our design, the code is clearly conditioned on whether <code>l</code> is empty or non-empty.
Furthermore, the results of the cases clearly implement the cases of our design, so we can believe our implementation is correct as long as we believe our design is correct.</p>
<p>Is there anything we can improve here?
Yes—some subtle, yet important things, in fact:</p>
<ul>
<li>We need to make sure that the guard of our conditional accurately reflects the cases of our data structure.
Here, our list is either empty or non-empty which is captured by an <code>is_empty</code> check.</li>
<li>We know that in the recursive case that our non-empty list is made up of a head and tail which we need to manually access using <code>head</code> and <code>tail</code>, respectively.
We locally bind names to these individual pieces so that we don't interchange <code>head</code> and <code>tail</code> calls in our code, but these bindings add additional complexity to our implementation.</li>
</ul>
<p>To fix these issues, we'll use the <em>pattern matching</em> facilities of Python to express our recursive design directly without the need for a guard expression or let-binding.
Note that when we talk about pattern matching here, we don't mean regular expression matching but instead a separate facilities of Python for writing code that looks at the <em>shape</em> of a data type.</p>
<p>First, we'll revise our list definition slightly based on the functions we use to construct lists.</p>
<blockquote>
<p>A list is either:</p>
<ul>
<li><code>[]</code>, the empty list.</li>
<li><code>cons(v, l)</code>, a non-empty list constructed that consists of a head element <code>v</code> and a list <code>l</code>.</li>
</ul>
</blockquote>
<p>Remember, in this recursive scheme, a list is ultimately composed of repeated <code>cons</code> calls ending in <code>[]</code>.
For example:</p>
<pre><code class="language-python">&gt;&gt;&gt; [1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
&gt; cons(1, cons(2, cons(3, cons(4, cons(5, []))))) 
[1, 2, 3, 4, 5]
</code></pre>
<p>Because of this, we know that our <em>constructive definition</em> of a list covers all possible lists.
Now, we'll use pattern matching to directly express <code>length</code> in terms of this constructive definition:</p>
<pre><code class="language-python">def length(l):
    match l:
        case []:
            return 0
        case [hd, *tl]:
            return 1 + length(tl)
</code></pre>
<p>This version of <code>length</code> behaves identically to the previous version of the code but is more concise, directly reflecting our constructive definition of a list.</p>
<p>The <em>pattern matching statement</em> in Python allows us to directly perform a case analysis on data:</p>
<ol>
<li>After the <code>match</code> keyword is the <em>scrutinee</em> or <em>subject</em> of the pattern match, <code>l</code>.</li>
<li>Following the scrutinee are <em>branches</em>, each one corresponding to a particular shape of the data we're analyzing.
<ul>
<li>Following the <code>case</code> keyword is a <em>pattern</em>, a particular value shape that the scrutinee must match in order for this branch to be selected.</li>
<li>On the next line after each <code>case</code> is the <em>body</em> of the pattern match that is evaluated when the scrutinee matches the branch's pattern.</li>
</ul>
</li>
</ol>
<p>Importantly, patterns may contain variables that are bound to parts of the scrutinee on a successful match.
The first pattern, the empty list <code>[]</code>, does not contain any such variables.
But the second pattern, a list literal pattern combined with an <em>unpacking</em> operator, binds the first element of the list to <code>hd</code> and the tail of the list to <code>tl</code>.
By using pattern matching, we no longer need to bind locals to name the subcomponents of a list!</p>
<h3 id="a-recursive-skeleton-for-lists"><a class="header" href="#a-recursive-skeleton-for-lists">A Recursive Skeleton for Lists</a></h3>
<p>Ultimately, the recursive design of a function contains two parts:</p>
<ul>
<li>Case analysis over a recursively-defined structure.</li>
<li>A recursive assumption allowing us to use the function recursively on a smaller object than the input.</li>
</ul>
<p>When we fix the structure, <em>e.g.</em>, lists, we arrive at a <em>skeleton</em> or template for defining recursive functions that operate on that structure.
This skeleton serves as a starting point for our recursive designs.
The skeleton always mimics the recursive definition of the structure:</p>
<div id="admonition-recursive-skeleton-for-lists" class="admonition admonish-info" role="note" aria-labelledby="admonition-recursive-skeleton-for-lists-title">
<div class="admonition-title">
<div id="admonition-recursive-skeleton-for-lists-title">
<p>Recursive Skeleton for Lists</p>
</div>
<a class="admonition-anchor-link" href="#admonition-recursive-skeleton-for-lists"></a>
</div>
<div>
<p>For an input list <code>l</code>:</p>
<ul>
<li>What do we do when <code>l</code> is empty (the <em>base case</em>)?</li>
<li>What do we do when <code>l</code> is non-empty (the <em>recursive case</em>)?
When <code>l</code> is non-empty, we have access to the head of <code>l</code> and the tail of <code>l</code> with pattern matching.
Furthermore, when <code>l</code> is non-empty, we can use our recursive assumption to recursively call our function on the tail of <code>l</code>.</li>
</ul>
</div>
</div>
<p>Note that this skeleton is only a starting point in our recursive design.
We may need to generalize or expand the skeleton, <em>e.g.</em>, by adding additional base cases depending on the problem.</p>
<div id="admonition-exercise-intersperse" class="admonition admonish-question" role="note" aria-labelledby="admonition-exercise-intersperse-title">
<div class="admonition-title">
<div id="admonition-exercise-intersperse-title">
<p>Exercise (Intersperse)</p>
</div>
<a class="admonition-anchor-link" href="#admonition-exercise-intersperse"></a>
</div>
<div>
<p>Write a high-level recursive design for the <code>list_intersperse</code> function.
<code>list_intersperse(v, l)</code> returns <code>l</code> but with <code>v</code> placed between every element of <code>l</code>.
For example:</p>
<pre><code class="language-python">&gt;&gt;&gt; list_intersperse(0, [1, 2, 3, 4, 5])
[1, 0, 2, 0, 3, 0, 4, 0, 5]
&gt;&gt;&gt; list_intersperse(0, [])
[]
&gt;&gt;&gt; list_intersperse(0, [1])
[1]
</code></pre>
<p>(<em>Hint</em>: this is an example of a function where its most elegant implementation comes from having <em>multiple base cases</em>.
Consider an additional base case in your recursive design.)</p>
</div>
</div>
<h2 id="inductive-reasoning-with-lists"><a class="header" href="#inductive-reasoning-with-lists">Inductive Reasoning with Lists</a></h2>
<p>Now that we've discussed how we write recursive programs over lists, we'll develop our primary technique for reasoning about recursive structures, <em>structural induction</em>.</p>
<h3 id="reasoning-about-recursive-functions"><a class="header" href="#reasoning-about-recursive-functions">Reasoning About Recursive Functions</a></h3>
<p>Let's come back to the proposition about <code>append</code> that we used to start our discussion of program correctness:</p>
<div id="admonition-claim" class="admonition admonish-question" role="note" aria-labelledby="admonition-claim-title">
<div class="admonition-title">
<div id="admonition-claim-title">
<p>Claim</p>
</div>
<a class="admonition-anchor-link" href="#admonition-claim"></a>
</div>
<div>
<p>For all lists <code>l1</code> and <code>l2</code>, <code>length(l1) + length(l2)</code> ≡ <code>length(append(l1, l2))</code>.</p>
</div>
</div>
<p>To prove this claim, we need the definitions of both <code>length</code> and <code>append</code>.</p>
<div id="admonition-exercise-append" class="admonition admonish-question" role="note" aria-labelledby="admonition-exercise-append-title">
<div class="admonition-title">
<div id="admonition-exercise-append-title">
<p>Exercise (Append)</p>
</div>
<a class="admonition-anchor-link" href="#admonition-exercise-append"></a>
</div>
<div>
<p>Try to design and implement <code>append(l1, l2)</code>, which returns the result of appending <code>l1</code> onto the front of <code>l2</code> without peeking below!</p>
</div>
</div>
<pre><code class="language-python">def length(l)
    match l:
        case []:
            return 0
        case [head, *tail]:
            return 1 + length(tail)

def append(l1, l2):
    match l1:
        case []:
            return l2
        case [head, *tail]:
            return cons(head, append(tail))
</code></pre>
<p>The proof proceeds similarly to all of our symbolic proofs so far: assume arbitrary values for the universally quantified variables and attempt to use symbolic evaluation.</p>
<div id="admonition-proof" class="admonition admonish-info" role="note" aria-labelledby="admonition-proof-title">
<div class="admonition-title">
<div id="admonition-proof-title">
<p>Proof</p>
</div>
<a class="admonition-anchor-link" href="#admonition-proof"></a>
</div>
<div>
<p><em>Proof</em>.
Let <code>l1</code> and <code>l2</code> be arbitrary lists.
The left-hand side of the equivalence evaluates to:</p>
<pre><code class="language-scheme">    length(l1) + length(l2)
--&gt; { match l1:
          case []:
              return 0
          case [head, *tail]:
              return 1 + length(tail) } + length(l2)
</code></pre>
<p>The right-hand side of the equivalence evaluates to:</p>
<pre><code class="language-python">    length(append(l1, l2))
--&gt; length({ match l1:
                 case []:
                     return l2
                 case [head, *tail]:
                     return cons(head, append(tail, l2)) })
</code></pre>
</div>
</div>
<p>At this point, both sides of the equivalence are stuck.
However, we know that because <code>l1</code> is a list, it is either empty or non-empty.
Therefore, we can proceed with a case analysis of this fact!</p>
<div id="admonition-proof-empty-case" class="admonition admonish-info" role="note" aria-labelledby="admonition-proof-empty-case-title">
<div class="admonition-title">
<div id="admonition-proof-empty-case-title">
<p>Proof (Empty Case)</p>
</div>
<a class="admonition-anchor-link" href="#admonition-proof-empty-case"></a>
</div>
<div>
<p>Either <code>l1</code> is empty or non-empty.</p>
<ul>
<li>
<p><code>l1</code> is empty, <em>i.e.</em>, <code>l1</code> is <code>[]</code>.
The left-hand side of the equivalence evaluates as follows:</p>
<pre><code class="language-python">...
--&gt; { match []:
          case []:
              return 0
          case [head, *tail]:
              return 1 + length(tail) } + length(l2)
--&gt; { return 0 }
--&gt; 0 + length(l2)
--&gt; length(l2)
</code></pre>
<p>On the right-hand side of the equivalence, we have:</p>
<pre><code class="language-python">...
--&gt; length({ match []:
                case []:
                    return l2
                case [head, *tail]:
                    return cons(head, append(tail, l2)) })
--&gt; length({ return l2 })
--&gt; length(l2)
</code></pre>
<p>Both sides evaluate to <code>(length l2)</code>, so they are equivalent!</p>
</li>
</ul>
</div>
</div>
<p>So the empty case works out just fine.
What about the non-empty case?</p>
<div id="admonition-proof-non-empty-case" class="admonition admonish-info" role="note" aria-labelledby="admonition-proof-non-empty-case-title">
<div class="admonition-title">
<div id="admonition-proof-non-empty-case-title">
<p>Proof (Non-empty Case)</p>
</div>
<a class="admonition-anchor-link" href="#admonition-proof-non-empty-case"></a>
</div>
<div>
<ul>
<li>
<p><code>l1</code> is non-empty.
Since <code>l1</code> is non-empty, <code>l1</code> is <code>(cons h t)</code> for some value <code>h</code> and list <code>t</code>, so on the left-hand side of the equivalence, we have:</p>
<pre><code class="language-python">...
--&gt; { match l1:
          case []:
              return 0
          case [head, *tail]:
              return 1 + length(tail) } + length(l2)
--&gt; { return 1 + length(tail) } + length(l2)
--&gt; (1 + length(tail)) + length(l2)
--&gt; 1 + (length(tail) + length(l2))
</code></pre>
<p>The final step of evaluation comes from the commutative property of addition: <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>.</p>
<p>On the right-hand side of the equivalence, we have:</p>
<pre><code class="language-python">...
--&gt; length({ match l1:
                case []:
                    return l2
                case [head, *tail]:
                    return cons(head, append(tail, l2)) })
--&gt; length({ return cons(head, append(tail, l2)) })
--&gt; length(cons(head, append(tai1, l2)))
--&gt; { match cons(head, append(tail, l2)):
          case []:
              return 0
          case [h2, t2]:
              return 1 + length(t2) }
--&gt; { return 1 + length(t2) }
--&gt; return 1 + length(t2)
--&gt; return 1 + length(append(tail, l2))
</code></pre>
</li>
</ul>
</div>
</div>
<p>Note that this evaluation is a bit trickier than the previous ones that we have seen.
In particular, we have to observe that the tail of <code>cons(x, y)</code> is simply <code>y</code>!
Nevertheless, if we push through accurately, we can persevere!</p>
<p>At this point, our equivalence in the non-empty case is:</p>
<pre><code class="language-python">1 + length(tail) + length(l2) ≡ 1 + length(append(tail, l2))
</code></pre>
<p><code>tail</code> is still abstract, so we can't proceed further.
One way to proceed is to note that <code>tail</code> itself is a list.
Therefore, we can perform case analysis on it---is <code>tail</code> empty or non-empty?</p>
<div id="admonition-proof-case-analysis-on-the-tail" class="admonition admonish-info" role="note" aria-labelledby="admonition-proof-case-analysis-on-the-tail-title">
<div class="admonition-title">
<div id="admonition-proof-case-analysis-on-the-tail-title">
<p>Proof (Case analysis on the tail)</p>
</div>
<a class="admonition-anchor-link" href="#admonition-proof-case-analysis-on-the-tail"></a>
</div>
<div>
<p>(Still in the case where <code>l1</code> is non-empty.)</p>
<p><code>tail</code> is either empty or non-empty.</p>
<ul>
<li>
<p><code>tail</code> is empty.
The left-hand side of the equivalence evaluates to:</p>
<pre><code class="language-python">...
--&gt; 1 + length([]) + length(l2)
--&gt; 1 + { match []:
              case []:
                  return 0
              case [head2, *tail2]:
                  return 1 + length(tail2) } + length(l2)
--&gt; 1 + { return 0 } + length(l2)
--&gt; 1 + 0 + length(l2)
--&gt; 1 + length(l2)
</code></pre>
<p>The right-hand side of the equivalence evaluates to:</p>
<pre><code class="language-python">...
--&gt; 1 + length(append([], l2))
--&gt; 1 + length({ match []:
                     case []:
                         return l2
                     case [head2, *tail2]:
                         return cons(head2, append(tail2, l2)) })
--&gt; 1 + length({ return l2 })
--&gt; 1 + length(l2)
</code></pre>
<p>Both sides of the equivalence are <code>1 + length(l2)</code>, completing this case.</p>
</li>
</ul>
</div>
</div>
<p>Note that when <code>tail</code> is empty, the original list <code>l1</code> only contains a single element.
Therefore, it should not be surprising that the equivalence boils down to demonstrating that both sides evaluates to <code>1 + length(l2)</code>.</p>
<p>Again, while the empty case works out, the non-empty case runs into problems.</p>
<div id="admonition-proof-case-analysis-on-the-tail-non-empty-case" class="admonition admonish-info" role="note" aria-labelledby="admonition-proof-case-analysis-on-the-tail-non-empty-case-title">
<div class="admonition-title">
<div id="admonition-proof-case-analysis-on-the-tail-non-empty-case-title">
<p>Proof (Case analysis on the tail, non-empty case)</p>
</div>
<a class="admonition-anchor-link" href="#admonition-proof-case-analysis-on-the-tail-non-empty-case"></a>
</div>
<div>
<p>(Still in the case where <code>l1</code> is non-empty.)</p>
<ul>
<li>
<p><code>tail</code> is non-empty.
The left-hand side of the equivalence evaluates to:</p>
<pre><code class="language-python">...
--&gt; 1 + length([]) + length(l2)
--&gt; 1 + { match []:
              case []:
                  return 0
              case [head2, *tail2]:
                  return 1 + length(tail2) } + length(l2)
--&gt; 1 + { return 1 + length(tail2) } + length(l2)
--&gt; 1 + (1 + length(tail2)) + length(l2)
--&gt; 1 + 1 + length(tail2) + length(l2)
</code></pre>
</li>
</ul>
</div>
</div>
<p><code>tail2</code> here is the tail of <code>tail</code>, <em>i.e.</em>, <code>tail(tail(l1))</code>!</p>
<p>Notice a pattern yet?
Here is where our case analyses have taken the left-hand side of the equivalence so far:</p>
<pre><code class="language-python">     length(l1) + length(l2)
--&gt;* &lt;... l1 is non-empty ...&gt;
--&gt;* 1 + length(tail) + length(l2)
--&gt;* &lt;... tail of l1 is non-empty ...&gt;
--&gt;* 1 + 1 + length(tail2) + length(l2)
</code></pre>
<p>We could now proceed with case analysis on <code>tail2</code>.
We'll find that the base/empty case is provable because in that case, we assume that <code>l1</code> has exactly two elements.
But then, we'll end up in the same situation we are in, but with one additional <code>(+ 1 ...</code> at the front of the expression!
Because the inductive structure is defined in terms of itself, and we are proving this property over <em>all</em> possible lists, we don't know when to stop our case analysis!</p>
<div id="admonition-exercise-the-other-side" class="admonition admonish-note" role="note" aria-labelledby="admonition-exercise-the-other-side-title">
<div class="admonition-title">
<div id="admonition-exercise-the-other-side-title">
<p>Exercise (The Other Side)</p>
</div>
<a class="admonition-anchor-link" href="#admonition-exercise-the-other-side"></a>
</div>
<div>
<p>We demonstrated that case analysis and evaluation of the equivalence's left-hand side seemingly has no end.
Perform a similar analysis of the equivalence's right-hand side, starting when <code>tail</code> is non-empty.
You should arrive at the point where the right-hand side evaluates to:</p>
<pre><code class="language-python">1 + 1 + length(append(tail2, l2))
</code></pre>
</div>
</div>
<h3 id="inductive-reasoning-1"><a class="header" href="#inductive-reasoning-1">Inductive Reasoning</a></h3>
<p>How do we break this seemingly infinite chain of reasoning?
We employ an <em>inductive assumption</em> similar to the recursive assumption we use to design recursive functions.
The recursive assumption is that our function "just works" for the tail of the list.
Our inductive assumption states that our original claim holds for the tail of the list!</p>
<p>Recall that our original claim stated:</p>
<div id="admonition-claim-1" class="admonition admonish-question" role="note" aria-labelledby="admonition-claim-1-title">
<div class="admonition-title">
<div id="admonition-claim-1-title">
<p>Claim</p>
</div>
<a class="admonition-anchor-link" href="#admonition-claim-1"></a>
</div>
<div>
<p>For all lists <code>l1</code> and <code>l2</code>, <code>length(l1) + length(l2) ≡ length(append(l1, l2))</code>.</p>
</div>
</div>
<p>Our <em>inductive assumption</em> is precisely the original claim but specialized to the tail of the list that we perform case analysis over.
We also call this inductive assumption our <em>inductive hypothesis</em>.</p>
<div id="admonition-inductive-hypotheiss" class="admonition admonish-info" role="note" aria-labelledby="admonition-inductive-hypotheiss-title">
<div class="admonition-title">
<div id="admonition-inductive-hypotheiss-title">
<p>Inductive Hypotheiss</p>
</div>
<a class="admonition-anchor-link" href="#admonition-inductive-hypotheiss"></a>
</div>
<div>
<p><code>length(tail) + length(l2) ≡ length(append(tail, l2))</code>.</p>
</div>
</div>
<p>While we are trying to prove the claim, the inductive hypothesis is an <em>assumption</em> we can use in our proof.</p>
<p>Let's unwind our proof back to the case analysis of <code>l1</code>.
The case where <code>l1</code> was empty was provable without this inductive hypothesis, so let's focus on the non-empty case.
Recall that before we performed case analysis, we arrived at a proof state where our goal equivalence to prove was:</p>
<pre><code class="language-python">1 + length(tail) + length(l2) ≡ 1 + length(append(tail, l2))
</code></pre>
<p>Compare this goal equivalence with our induction hypothesis above.
We see that the left-hand side of the induction hypothesis equivalence, <code>length(tail) + length(l2)</code>, is contained in the left-hand side of the goal equivalence.
Because our induction hypothesis states that this expression is equivalent to <code>length(append(tail, l2))</code>, we can <em>rewrite</em> the former expression to the latter expression in our goal!
This fact allows us to finish the proof as follows:</p>
<div id="admonition-proof-completed-finally" class="admonition admonish-info" role="note" aria-labelledby="admonition-proof-completed-finally-title">
<div class="admonition-title">
<div id="admonition-proof-completed-finally-title">
<p>Proof (Completed, finally!)</p>
</div>
<a class="admonition-anchor-link" href="#admonition-proof-completed-finally"></a>
</div>
<div>
<ul>
<li>
<p><code>l1</code> is non-empty.
Our induction hypothesis states that:</p>
<pre><code class="language-python">`length(tail) + length(l2) ≡ length(append(tail, l2))`
</code></pre>
<p>Since <code>l1</code> is non-empty, evaluation simplifies the goal equivalence to:</p>
<pre><code class="language-python">1 + length(tail) + length(l2) ≡ 1 + length(append(tail, l2))
</code></pre>
<p>By our induction hypothesis, we can rewrite this goal to:</p>
<pre><code class="language-python">1 + length(append(tail, l2)) ≡ 1 + length(append(tail, l2))
</code></pre>
<p>Which completes the proof.</p>
</li>
</ul>
</div>
</div>
<p>We call a proof that uses an induction hypothesis a <em>proof by induction</em> or <em>inductive proof</em>.
Like recursion in programming, inductive proofs are pervasive in mathematics.</p>
<p>In summary, here is a complete inductive proof of the <code>append</code> claim.
In this proof, we'll step directly from a call to <code>length</code> or <code>append</code> directly to the branch of the <code>match</code> that we would have selected.
We'll take this evaluation shortcut moving forward to avoid cluttering our proof.</p>
<p>Note in our proof that we declare that we "proceed by induction on <code>l1</code>" and then move into a case analysis.
This exemplifies how we should think of inductive proof moving forward:</p>
<div id="admonition-inductive-proof" class="admonition admonish-info" role="note" aria-labelledby="admonition-inductive-proof-title">
<div class="admonition-title">
<div id="admonition-inductive-proof-title">
<p>Inductive proof</p>
</div>
<a class="admonition-anchor-link" href="#admonition-inductive-proof"></a>
</div>
<div>
<p>An inductive proof is a <em>case analysis</em> over a <em>recursively-defined structure</em> with the additional benefit of an <em>induction hypothesis</em> to avoid infinite reasoning.</p>
</div>
</div>
<div id="admonition-proof-1" class="admonition admonish-success" role="note" aria-labelledby="admonition-proof-1-title">
<div class="admonition-title">
<div id="admonition-proof-1-title">
<p>Proof</p>
</div>
<a class="admonition-anchor-link" href="#admonition-proof-1"></a>
</div>
<div>
<p><strong>Claim</strong>: for all lists <code>l1</code> and <code>l2</code>, <code>length(l1) + length(l2)</code> ≡ <code>length(append(l1, l2))</code>.</p>
<p><em>Proof</em>.
We proceed by induction on <code>l1</code>.</p>
<ul>
<li>
<p><code>l1</code> is empty, thus <code>l1</code> is <code>[]</code>.
The left-hand side of the equivalence evaluates as follows:</p>
<pre><code class="language-python">    length([]) + length(l2)
--&gt; 0 + length(l2)
--&gt; length(l2)
</code></pre>
<p>On the right-hand side of the equivalence, we have:</p>
<pre><code class="language-python">    length(append([], l2))
--&gt; length(l2)
</code></pre>
</li>
<li>
<p><code>l1</code> is non-empty.
Let <code>head</code> and <code>tail</code> be the head element and tail of <code>l1</code>, respectively.
Our induction hypothesis is:</p>
<p><strong>Inductive hypothesis</strong>: <code>length(tail) + length(l2)</code> ≡ <code>length(append(tail, l2))</code>.</p>
<p>On the left-hand side of the equivalence, we have:</p>
<pre><code class="language-python">--&gt; length(l1) + length(l2)
--&gt; (1 + length(tail)) + length(l2)
  ≡ 1 + (length(tail) + length(l2))
</code></pre>
<p>The final step comes from the commutative property of addition: <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>.</p>
<p>On the right-hand side of the equivalence, we have:</p>
<pre><code class="language-scheme">--&gt; length(append(l1, l2))
--&gt; length(cons(head, append(tail, l2)))
--&gt; 1 + length(append(tail, l2))
</code></pre>
<p>In summary, we now have:</p>
<pre><code class="language-python">1 + (length(tail) + length(l2)) ≡ 1 + length(append(tail, l2))
</code></pre>
<p>We can use our induction hypothesis to rewrite the left-hand side of the equivalence to the right-hand side:</p>
<pre><code class="language-python">1 + length(append(tail, l2)) ≡ 1 + length(append(tail, l2))
</code></pre>
<p>Completing the proof.</p>
</li>
</ul>
</div>
</div>
<div id="admonition-exercise-switcharoo-" class="admonition admonish-note" role="note" aria-labelledby="admonition-exercise-switcharoo--title">
<div class="admonition-title">
<div id="admonition-exercise-switcharoo--title">
<p>Exercise (Switcharoo, ‡)</p>
</div>
<a class="admonition-anchor-link" href="#admonition-exercise-switcharoo-"></a>
</div>
<div>
<p>In our proof of the correctness of <code>append</code>, we performed induction on <code>l1</code>.
Could we have instead performed induction on <code>l2</code>?
Try it out!
And based on your findings, explain why or why not in a few sentences.</p>
</div>
</div>
<footer>Tools for Thinking About Programs: Mathematical Foundations © 2025 by <a href='https://iampmo.com'>Peter-Michael Osera</a> is licensed under <a href='https://creativecommons.org/licenses/by-nc/4.0/'>CC BY-NC 4.0</a>.</footer>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../program-correctness/preconditions-and-proof-states.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../program-correctness/mathematical-induction.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../program-correctness/preconditions-and-proof-states.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../program-correctness/mathematical-induction.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
