<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Symbolic Execution - Tools for Thinking About Programs: Mathematical Foundations</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././book.css">
        <link rel="stylesheet" href=".././mdbook-admonish.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Tools for Thinking About Programs: Mathematical Foundations</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="symbolic-execution"><a class="header" href="#symbolic-execution">Symbolic Execution</a></h1>
<p>Previously, we introduced a model of computation for the Racket programming language.
This model allows us to prove program properties when concrete values are involved.
However, we frequently wish to prove properties where the values are <em>unknown</em>.
For example, we might consider a proposition about the standard <code>list_append</code> function:</p>
<blockquote>
<p>For all lists <code>l1</code> and <code>l2</code>, <code>len(l1) + len(l2)</code> = <code>len(list_append(l1, l2))</code></p>
</blockquote>
<p>This proposition ranges over <em>unknown</em>, rather than concrete, lists.
We, therefore, need to upgrade our mental model to work with these unknown quantities.</p>
<h2 id="abstract-propositions"><a class="header" href="#abstract-propositions">Abstract Propositions</a></h2>
<p>Up to this point, we have considered concrete expressions, <em>i.e.</em>, expressions that do not contain variables.
What happens if we allow expressions to contain variables.
As an example, consider the following implementation of the boolean <code>and</code> function:</p>
<pre><code class="language-python"># N.B. non-short-circuiting version of `and`
def my_and(b1, b2):
    if b1:
        return b2
    else:
        return False
</code></pre>
<p>Now, let's consider the following equivalence claim:</p>
<p><strong>Claim</strong>: <code>my_and(True, b)</code> ≡ <code>False</code></p>
<p>Here, <code>b</code> is a variable, presumed to be of boolean type.
However, how do we interpret <code>b</code>?
It turns out there are two interpretations we might consider:</p>
<ul>
<li>Does there <em>exist</em> a boolean value to <code>b</code> so that the proposition is provable?</li>
<li>Is the proposition provable <em>for all</em> possible boolean values that <code>b</code> can take on?</li>
</ul>
<p>The former interpretation is called an <em>existential quantification</em> of <code>b</code>.
We alternatively say that <code>b</code> is existentially quantified or is an "existential."
<em>Quantification</em> refers to the fact that our interpretation tells us "how many" values of <code>b</code> to consider in the proposition.
In existential quantification, we consider a single value.</p>
<p>In contrast, the latter interpretation is called a <em>universal quantification</em> of <code>b</code>.
In universal quantification, we mean that the proposition holds for all possible values of <code>b</code>.
Note that the above proposition is provable if <code>b</code> is interpreted existentially: if we let <code>b</code> be <code>#f</code> then:</p>
<pre><code class="language-python">    my_and(True, b)
--&gt; my_and(True, False)
--&gt; { if True: return False else: return False }
--&gt; { return False }
--&gt; False
</code></pre>
<p>However, the proposition does not hold when <code>b</code> is universally quantified.
More specifically, while it holds when <code>b</code> is <code>False</code>, it does not hold when <code>b</code> is <code>True</code>.</p>
<pre><code class="language-python">    my_and(True, b)
--&gt; my_and(True, True)
--&gt; { if True: return False else: return False }
--&gt; { return False }
--&gt; False
</code></pre>
<p>Because of this, we must be explicit when introducing variables into our proposition.
For each such variable, we must <em>declare</em> whether it is existentially quantified and universally quantified.
To do so, we can use the words:</p>
<ul>
<li><em>For all</em> for universal quantification, <em>e.g.</em>, "for all lists <code>l</code> …" and</li>
<li><em>There exists</em> for existential quantification, <em>e.g.</em>, "there exists a number <code>n</code> …".</li>
</ul>
<p>Furthermore, we reason about the variable differently depending on its quantification, as we see in the following sections.</p>
<div id="admonition-exercise-quantified-propositions" class="admonition admonish-note" role="note" aria-labelledby="admonition-exercise-quantified-propositions-title">
<div class="admonition-title">
<div id="admonition-exercise-quantified-propositions-title">
<p>Exercise (Quantified Propositions)</p>
</div>
<a class="admonition-anchor-link" href="#admonition-exercise-quantified-propositions"></a>
</div>
<div>
<p>Write down an additional <em>existential</em> and <em>universal</em> claim involving the <code>my_and</code> function.</p>
</div>
</div>
<h2 id="existential-propositions"><a class="header" href="#existential-propositions">Existential Propositions</a></h2>
<p>If a variable <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> appears as an existential in a proposition, we interpret that variable as: <em>there exists</em> a value for <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> such that the proposition holds.
In other words, the proposition is provable if we can give a <em>single value</em> to substitute for <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> so that the resulting proposition is provable.
Thus, to prove an existential claim, we can choose such a value, substitute for the existential variable, and then use concrete evaluation as before.</p>
<p>As an example, let's formally prove the existential version of the <code>my_and</code> claim that we introduced above:</p>
<div id="admonition-proof" class="admonition admonish-success" role="note" aria-labelledby="admonition-proof-title">
<div class="admonition-title">
<div id="admonition-proof-title">
<p>Proof</p>
</div>
<a class="admonition-anchor-link" href="#admonition-proof"></a>
</div>
<div>
<p><strong>Claim</strong>: there exists a boolean <code>b</code> such that <code>my_and(True, b)</code> ≡ <code>False</code>.</p>
<p><em>Proof</em>.
Let <code>b</code> be <code>False</code>.
Then we have:</p>
<pre><code class="language-python">    my_and(True, False)
--&gt; my_and(True, False)
--&gt; { if True: return False else: return False }
--&gt; { return False }
--&gt; False
</code></pre>
</div>
</div>
<p>Note how our proof has changed now that our proposition is abstract:</p>
<ol>
<li>In our claim, we explicitly quantify the variable <code>b</code> by declaring it existential by using "there exists" to describe it.</li>
<li>In our proof, we explicitly <em>choose</em> a value for the existentially quantified variable ("Let <code>b</code> be <code>False</code>").</li>
</ol>
<p>We can also existentially quantify over multiple variables.
In these situations, we provide instantiations for each variable but otherwise proceed as normal.</p>
<div id="admonition-proof-1" class="admonition admonish-success" role="note" aria-labelledby="admonition-proof-1-title">
<div class="admonition-title">
<div id="admonition-proof-1-title">
<p>Proof</p>
</div>
<a class="admonition-anchor-link" href="#admonition-proof-1"></a>
</div>
<div>
<p><strong>Claim</strong>: There exists lists <code>l1</code> and <code>l2</code> such that <code>list_append(l1, l2)</code> ≡ <code>[1 2 3]</code>.</p>
<p><em>Proof</em>.
Let <code>l1</code> be <code>[]</code> (the empty list) and <code>l2</code> be <code>[1 2 3]</code>.</p>
<pre><code class="language-python">    list_append([], [1, 2, 3])
--&gt; { if is_empty([]):
          return [1, 2, 3]
      else:
          return cons(head([]), list_append(tail([]), [1, 2, 3]))
    }
--&gt; { if True:
          return [1, 2, 3]
      else:
          return cons(head([]), list_append(tail([]), [1, 2, 3]))
    }
--&gt; { return [1, 2, 3] }
--&gt; [1, 2, 3]
</code></pre>
</div>
</div>
<div id="admonition-exercise-alternative-instantiation" class="admonition admonish-note" role="note" aria-labelledby="admonition-exercise-alternative-instantiation-title">
<div class="admonition-title">
<div id="admonition-exercise-alternative-instantiation-title">
<p>Exercise (Alternative Instantiation)</p>
</div>
<a class="admonition-anchor-link" href="#admonition-exercise-alternative-instantiation"></a>
</div>
<div>
<p>Revise the proof of <code>list-append</code> above by choosing <em>alternative instantiations</em> for <code>l1</code> and <code>l2</code> and deriving an alternative execution trace for the expression.</p>
</div>
</div>
<h2 id="universal-quantification"><a class="header" href="#universal-quantification">Universal Quantification</a></h2>
<p>When a variable is universally quantified, it stands for <em>any possible</em> value.
Let's take a look at a simple squaring function:</p>
<pre><code class="language-python">def square(n):
    return n * n
</code></pre>
<p>And a simple universal claim about this function:</p>
<div id="admonition-claim" class="admonition admonish-question" role="note" aria-labelledby="admonition-claim-title">
<div class="admonition-title">
<div id="admonition-claim-title">
<p>Claim</p>
</div>
<a class="admonition-anchor-link" href="#admonition-claim"></a>
</div>
<div>
<p>for all numbers <code>n</code>, <code>square(n)</code> ≡ <code>n * n</code>.</p>
</div>
</div>
<p>Because the claim holds for all possible values of <code>n</code>, we can't <em>choose</em> a <code>n</code> like with existentials.
Instead, we must <em>hold <code>n</code> abstract</em>, <em>i.e.</em>, consider it to be an arbitrary number, and then proceed with the proof.
In effect, because <code>n</code> is universally quantified, we treat <code>n</code> like a constant, yet unknown, quantity in our reasoning.</p>
<div id="admonition-variables-versus-unknown-constants" class="admonition admonish-info" role="note" aria-labelledby="admonition-variables-versus-unknown-constants-title">
<div class="admonition-title">
<div id="admonition-variables-versus-unknown-constants-title">
<p>Variables versus Unknown Constants</p>
</div>
<a class="admonition-anchor-link" href="#admonition-variables-versus-unknown-constants"></a>
</div>
<div>
<p>It may seem pedantic to distinguish between a variable and a constant of unknown quantity.
However, there a subtle yet essential difference between the two concepts.
A variable is an object in a proposition that must be <em>quantified</em> to give it meaning.
An unknown constant already has meaning---it is known to be a single value.
However, we don't assume anything about the variable's identity beyond what we already know, <em>e.g.</em>, whether it is a list or a number.</p>
</div>
</div>
<p>When we use our mental model of computation, we immediately arrive at a problem: both <code>square(n)</code> and <code>n * n</code> cannot take any evaluation steps!
<code>square(n)</code> cannot step because <code>n</code> needs to be a value before we perform the function application, and we said that values were numbers, boolean constants, or lambdas.
<code>n * n</code> cannot step because since we don't know what <code>n</code> is, we don't know what concrete value the multiplication will produce.
We say that both expressions are <em>stuck</em>: they are not values, but they cannot take any additional evaluation steps.</p>
<p>We can't reconcile the <code>n * n</code> case.
Without knowing what <code>n</code> is, we cannot carry out the multiplication.
However, if we treat the constant-yet-unknown <code>n</code> as a <em>value</em>, then we can proceed with the function application:</p>
<pre><code class="language-python">    square(n)
--&gt; n * n
</code></pre>
<p>Even though the left- and right-hand sides of the equivalence are not values, they are identical.
This fact is sufficient to conclude that the two original expressions are equivalent according to our definition of program equivalences!
Let's put these ideas together into a complete proof of the proposition:</p>
<div id="admonition-proof-2" class="admonition admonish-success" role="note" aria-labelledby="admonition-proof-2-title">
<div class="admonition-title">
<div id="admonition-proof-2-title">
<p>Proof</p>
</div>
<a class="admonition-anchor-link" href="#admonition-proof-2"></a>
</div>
<div>
<p><strong>Claim</strong>: for all numbers <code>n</code>, <code>square(n)</code> ≡ <code>n * n</code>.</p>
<p><em>Proof</em>.
Let <code>n</code> be an arbitrary number.
Then the left-hand side of the equivalence simplifies to <code>square(n) --&gt; n * n</code>, which is identical to the right-hand side.</p>
</div>
</div>
<p>In summary, when we encounter a universally quantified variable in a proposition, we:</p>
<ol>
<li>Consider the variable to be a constant, yet unknown value.
For convenience, we keep the name of this constant to be the same as the (universally quantified) variable, but we understand that the two are different objects!</li>
<li>When reasoning about the constant, we assume that it is a value for the purposes of our mental model of computation.</li>
</ol>
<h2 id="case-analysis"><a class="header" href="#case-analysis">Case Analysis</a></h2>
<p>Sometimes when we work with universally quantified variables, we can get away without thinking about their actual values.
However, more often or not, our reasoning must consider their possible values.
This reasoning will ultimately depend on the types of values involved, and this is where our proofs get more intricate in their design!</p>
<p>As an introduction to these concepts, let's consider the case where we know the type in question only allows for a <em>finite set of values</em>.
At present, only the <em>boolean type</em> has this property.
Booleans only allow for two values, <code>True</code> and <code>False</code>, whereas there are an infinite number of numbers and functions to choose from!</p>
<p>To see how we can take advantage of the finiteness of the boolean type in our proofs, let's consider the following simple claim, again using the <code>my_and</code> function:</p>
<div id="admonition-claim-1" class="admonition admonish-question" role="note" aria-labelledby="admonition-claim-1-title">
<div class="admonition-title">
<div id="admonition-claim-1-title">
<p>Claim</p>
</div>
<a class="admonition-anchor-link" href="#admonition-claim-1"></a>
</div>
<div>
<p>For all booleans <code>b</code>, <code>my_and(b, False)</code> ≡ <code>False</code>.</p>
</div>
</div>
<p>If we let <code>b</code> be arbitrary, we can begin evaluating the left-hand expression.</p>
<pre><code class="language-python">    my_and(b, False)
--&gt; { if b: return False else: return False }
</code></pre>
<p>We can see pretty readily that no matter how the conditional evaluates, we will return <code>False</code>.
Be careful, though; this intuition is not sufficient for formal proof!
We must instead rely on our evaluation model directly to ultimately show that this intuition is correct.
However, if <code>b</code> is unknown, we don't know which branch the conditional will produce.</p>
<p>Thankfully, we assumed that <code>b</code> was a boolean, so it must either be <code>True</code> or <code>False</code>.
Therefore, we can proceed by <em>case analysis</em>: we will consider two separate cases, <code>b</code> is <code>True</code> and <code>b</code> is <code>False</code>, and show that the claim holds in <em>both</em> cases.
If the claim holds for both cases, we know that the claim holds for <em>every possible value of <code>b</code></em> and, thus, have completed the proof.</p>
<div id="admonition-proof-3" class="admonition admonish-success" role="note" aria-labelledby="admonition-proof-3-title">
<div class="admonition-title">
<div id="admonition-proof-3-title">
<p>Proof</p>
</div>
<a class="admonition-anchor-link" href="#admonition-proof-3"></a>
</div>
<div>
<p><em>Proof</em>.
Let <code>b</code> be an arbitrary boolean.
The left-hand side of the equivalence evaluates as follows:</p>
<pre><code class="language-scheme">    my_and(b, False)
--&gt; { if b: return False else: return False }
</code></pre>
<p>Because <code>b</code> is a boolean, either <code>b</code> is <code>True</code> or <code>b</code> is <code>False</code>.</p>
<ul>
<li><strong><code>b</code> is <code>True</code></strong>.
Then <code>{ if True: return False else: return False } --&gt; { return False } --&gt; False</code></li>
<li><strong><code>b</code> is <code>False</code></strong>.
Then <code>{ if False: return False else: return False } --&gt; { return False } --&gt; False</code></li>
</ul>
<p>In both cases, the left-hand side steps to <code>False</code>, precisely the right-hand side of the equivalence.</p>
</div>
</div>
<div id="admonition-typesetting-cases" class="admonition admonish-note" role="note" aria-labelledby="admonition-typesetting-cases-title">
<div class="admonition-title">
<div id="admonition-typesetting-cases-title">
<p>Typesetting Cases</p>
</div>
<a class="admonition-anchor-link" href="#admonition-typesetting-cases"></a>
</div>
<div>
<p>When performing a case analysis, it is imperative to state the proof's different cases explicitly.
To format this in LaTeX, use a bulleted lists, <em>e.g.</em>,</p>
<pre><code class="language-markdown">\begin{proof}
  Because \code{b} is a boolean, either \code{b} is \code{True} or \code{b} is \code{False}.

  \begin{itemize}
  \item \textbf{\code{b} is \code{True}}.
    Then \code{ \{ if True: return False else: return False \} --&gt; \{ return False \} --&gt; False }
  \item \textbf{\code{b} is \code{False}}.
    Then \code{ \{ if False: return False else: return False \} --&gt; \{ return False \} --&gt; False }`
  \end{itemize}

  In both cases, the left-hand side steps to \code{#f}, precisely the right-hand side of the equivalence.
\end{proof}
</code></pre>
<p>Note how I bold each case at the start of the bullet to clearly separate the statement of the case from the subsequent proof.</p>
</div>
</div>
<div id="admonition-exercise-order-of-reasoning" class="admonition admonish-note" role="note" aria-labelledby="admonition-exercise-order-of-reasoning-title">
<div class="admonition-title">
<div id="admonition-exercise-order-of-reasoning-title">
<p>Exercise (Order of Reasoning)</p>
</div>
<a class="admonition-anchor-link" href="#admonition-exercise-order-of-reasoning"></a>
</div>
<div>
<p>In the previous proof, we performed the case analysis on \code{b} <em>after</em> partially evaluating \code{my_and}.
Rewrite the proof so that the case analysis happens <em>before</em> any evaluation occurs.
Was either approach more concise? Easier to reason about? Why?</p>
</div>
</div>
<div id="admonition-exercise-quantified-propositions-" class="admonition admonish-note" role="note" aria-labelledby="admonition-exercise-quantified-propositions--title">
<div class="admonition-title">
<div id="admonition-exercise-quantified-propositions--title">
<p>Exercise (Quantified Propositions, ‡)</p>
</div>
<a class="admonition-anchor-link" href="#admonition-exercise-quantified-propositions-"></a>
</div>
<div>
<p><strong>Exercise (Quantified Propositions, ‡)</strong>: consider the following Python definition of the boolean disjunction, \code{or}, function:</p>
<pre><code class="language-python">def my_of(b1, b2)
    if b1:
        True
    else:
        b2
</code></pre>
<p>Prove the following claims over this function:</p>
<ul>
<li><strong>Claim 1</strong>: there exists booleans <code>b1</code> and <code>b2</code> such that <code>my_or(b1, b2)</code> ≡ <code>False</code>.</li>
<li><strong>Claim 2</strong>: for all booleans <code>b</code>, <code>my_or(b, True)</code> ≡ <code>True</code>.</li>
</ul>
</div>
</div>
<footer>Tools for Thinking About Programs: Mathematical Foundations © 2025 by <a href='https://iampmo.com'>Peter-Michael Osera</a> is licensed under <a href='https://creativecommons.org/licenses/by-nc/4.0/'>CC BY-NC 4.0</a>.</footer>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../program-correctness/propositions-and-proofs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../program-correctness/preconditions-and-proof-states.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../program-correctness/propositions-and-proofs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../program-correctness/preconditions-and-proof-states.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
